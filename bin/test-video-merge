#!/usr/bin/env ruby

require 'bundler/setup'
require 'jiki-config'
require_relative '../config/environment'

puts "=== Testing Video Merge Locally ==="
puts ""

bucket = Jiki.config.s3_bucket_video_production

# Step 1: Check prerequisites
print "Checking LocalStack S3... "
begin
  Jiki.s3_client.head_bucket(bucket: bucket)
  puts "✓"
rescue StandardError => e
  puts "✗"
  puts "Error: LocalStack not accessible"
  puts "Run: bin/dev"
  exit 1
end

print "Checking Lambda function... "
begin
  Jiki.lambda_client.get_function(function_name: 'jiki-video-merger-development')
  puts "✓"
rescue StandardError => e
  puts "✗"
  puts "Error: Lambda function not deployed"
  puts "Run: bin/setup-video-production"
  exit 1
end

print "Checking test videos exist... "
begin
  Jiki.s3_client.head_object(bucket: bucket, key: 'test-assets/video1.mp4')
  Jiki.s3_client.head_object(bucket: bucket, key: 'test-assets/video2.mp4')
  puts "✓"
rescue StandardError => e
  puts "✗"
  puts "Error: Test videos not found"
  puts "Run: bin/seed-test-videos"
  exit 1
end

puts ""
puts "All prerequisites met!"
puts ""

# Step 2: Create pipeline
print "Creating test pipeline... "
pipeline = VideoProduction::Pipeline.create!(
  title: "Test Video Merge",
  version: "1.0",
  config: {}
)
puts "✓ (#{pipeline.uuid})"

# Step 3: Create asset nodes (with output already set since they're "completed")
print "Creating video asset nodes... "
video1 = VideoProduction::Node.create!(
  pipeline: pipeline,
  title: "Blue Video (3s)",
  type: "asset",
  asset: { type: "video", source: "s3://#{bucket}/test-assets/video1.mp4" },
  output: { type: "video", s3Key: "test-assets/video1.mp4" },
  status: "completed"
)

video2 = VideoProduction::Node.create!(
  pipeline: pipeline,
  title: "Red Video (3s)",
  type: "asset",
  asset: { type: "video", source: "s3://#{bucket}/test-assets/video2.mp4" },
  output: { type: "video", s3Key: "test-assets/video2.mp4" },
  status: "completed"
)
puts "✓"

# Step 4: Create merge node
print "Creating merge node... "
merge_node = VideoProduction::Node.create!(
  pipeline: pipeline,
  title: "Merged Video",
  type: "merge-videos",
  config: { "provider" => "ffmpeg" },
  inputs: { "segments" => [video1.uuid, video2.uuid] },
  status: "pending"
)
puts "✓ (#{merge_node.uuid})"

puts ""
puts "Pipeline created successfully!"
puts ""

# Step 5: Execute merge
puts "Executing video merge..."
puts "Input 1: s3://#{bucket}/test-assets/video1.mp4 (blue, 3s)"
puts "Input 2: s3://#{bucket}/test-assets/video2.mp4 (red, 3s)"
puts "Expected output: 6 second video (blue then red)"
puts ""

print "Running executor... "
begin
  VideoProduction::Node::Executors::MergeVideos.new(merge_node).call
  puts "✓"
rescue StandardError => e
  puts "✗"
  puts "Error: #{e.message}"
  puts e.backtrace.first(5).join("\n")
  exit 1
end

# Step 6: Check results
merge_node.reload
puts ""
puts "=== Results ==="
puts ""
puts "Status: #{merge_node.status}"

if merge_node.status == 'completed'
  puts "Output:"
  puts "  S3 Key: #{merge_node.output['s3Key']}"
  puts "  Duration: #{merge_node.output['duration']}s"
  puts "  Size: #{merge_node.output['size'] / 1024}KB"
  puts ""
  puts "✓ Video merge completed successfully!"
  puts ""
  puts "Output location: s3://#{bucket}/#{merge_node.output['s3Key']}"
  puts ""
  puts "To download and verify:"
  puts "  bin/rails runner \"File.write('merged.mp4', Jiki.s3_client.get_object(bucket: '#{bucket}', key: '#{merge_node.output['s3Key']}').body.read)\""
  puts "  open merged.mp4  # Should show blue video (3s) then red video (3s)"
elsif merge_node.status == 'failed'
  puts "Error: #{merge_node.metadata['error']}"
  puts ""
  puts "✗ Video merge failed"
  exit 1
else
  puts "Status: #{merge_node.status}"
  puts "Metadata: #{merge_node.metadata.inspect}"
  puts ""
  puts "⚠ Unexpected status"
  exit 1
end
